//- ============================================================================
//- Mathigon | Divisibility and Primes
//- (c) 2017 Mathigon
//- ============================================================================


mixin grid(n, fn)
  .number-grid
    - var i = 1
    while i <= n
      .number-cell= i
        if fn
          - var badge = fn(i)
          if badge
            .number-badge= badge
      - i += 1

mixin divisor-table(divisors, pairs)
  - var len = divisors.length
  - var last = divisors[len-1]
  table.divisor-table
    tr
      td.td-border-right(width="24")= last
      for i in divisors
        td.divisor-number(width="24")= i + (i == last ? '' : ',')
    for i in pairs
      tr
        td
        if i
          td(colspan=i)
        td(colspan=len - 2 * i): .divisor-pair(style="height: " + (len/2 - i) + "00%")
        if i
          td(colspan=i)

mixin blank(choices)
  x-blank(choices=choices)

mixin var(bind)
  if bind
    x-var(bind=bind)
      | ${
      block
      | }
  else
    span.var
      | ${
      block
      | }

mixin input(answer)
  x-blank(input=answer)

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#divisibility1(data-gloss="factor multiple divisor")

  .chapter-intro
    span.user Remember to #[x-target(to=".nav-link.dropdown-title") login] to save your progress and get personalised content.
    | &nbsp;
    span.size This textbook works best on larger devices like tablets or laptops.

  h2 Factors and Multiples

  p By now you should be comfortable with basic integer arithmetic and addition, subtraction and multiplication. Division is slightly different, because you  can’t always divide any integer by any other. For example 17 divided by 3 is not a whole number – it is somewhere in between 5 and 6. You either have to give a remainder (2), or express the answer as a decimal number (5.66).

  .row.padded
    .grow
      include svg/divisibility-1.svg
      p.caption 12 is divisible by 3
    .grow
      include svg/divisibility-2.svg
      p.caption 10 is not divisible by 4

  p If you can divide a number #[strong.red A] by a number #[strong.blue B], without remainder, we say that #[strong.blue B] is a #[strong factor] (or #[strong divisor]) of #[strong.red A], and that #[strong.red A] is a #[strong multiple] of #[strong.blue B]. We often write #[strong.blue B]|#[strong.red A], where the vertical bar simply means #[em “divides”].
  p For example, #[strong.green 7] × 3 = #[strong.orange 21], so #[strong.green 7] is a #[+blank("factor|multiple")] of #[strong.orange 21], #[strong.orange 21] is a #[+blank("multiple|factor")] of #[strong.green 7], and #[strong.green 7]|#[strong.orange 21].

section#divisibilitygame
  p In this short game you have to determine which numbers are factors or multiples, as fast as possible. Click the #[x-target(to="#divisibilitygame .toggle") play button] to start.

  .box.problem-box
    .box-title: h3 Factors and Multiples Quiz
    //- .box-body
      p.todo Exercises under development…
    x-gameplay.box-body
      .factors-row
        .factor-number ${x}
        | is a
        .factor-value
          .factor-bubble: .btn.btn-blue.btn-bounce factor
          .factor-bubble: .btn.btn-blue.btn-bounce multiple
          .factor-bubble: .btn.btn-blue.btn-bounce neither
        | of
        .factor-number ${y}

  p In the next section we will learn various techniques to easily check if a number is divisible by another.

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#divisibility2
  h2 Divisibility Rules
  h3 Divisibility by 2 and 5

  p Every number is divisible by 1. To determine if a number is divisible by 2, we simply have to check if it’s even: any number that ends in 0, 2, 4, 6, or 8 is divisible by 2.
  +grid(30)

//- ---------------------------------------------------------------------------

section#divisibility5
  p To see if a number is divisibility by 5 we similarly just have to check that its last digit is 0 or 5:
  +grid(30)

//- ---------------------------------------------------------------------------

section
  p The reason why these rules for 2 and 5 are so simple has to do with our number system. The base of our number system is 10, which means that every digit in a number is worth 10 times as much as the next one to the right. If we take the number 6382 as an example,

  table.base-10.base-10-fixed
    tr.base-10-large
      td: strong 6
      td: strong 3
      td: strong 8
      td: strong 2
    tr.caption
      td: | =6000
      td: | =300
      td: | =80
      td: | =2


  p Now we can separate the last digit of a number from all its other digits:

  table.table-tiny
    tr.base-10-large
      td #[strong.m-red abc]#[strong.m-green d]
      td: | =
      td #[strong.m-red abc × 10]
      td +
      td #[strong.m-green d]
    tr.caption
      td #[strong.m-red 638]#[strong.m-green 2]
      td: | =
      td #[strong.m-red 638 × 10]
      td +
      td #[strong.m-green 2]

  p Both 2 and 5 are factors of 10, so they will #[+blank('always divide|never divide|sometimes divide')] #[strong.m-red abc × 10], no matter what the values of #[strong.m-red a], #[strong.m-red b] and #[strong.m-red c] are. Therefore we only have to check the last digit: if #[strong.m-green d] is divisible by 2 then #[+blank('the whole number|abc')] is also divisible by 2. If #[strong.m-green d] is divisible by 5 then the whole number is divisible by 5.

//- ---------------------------------------------------------------------------

section#divisibility4
  h3 Divisibility by 4 and 8

  p Unfortunately 4 doesn’t divide 10, so we can‘t just look at the last number – but 4 #[em does] divide 100, so we just have to slightly modify our rule from above. Now we write #[strong.m-red ab]#[strong.m-green cd] = #[strong.m-red ab × 100] + #[strong.m-green cd]. We know that 4 will always divide #[strong.m-red ab × 100], so we have to look at the last #[+input(2)] digits to check if a number if divisible by 4.

  p For example, #[strong.m-green 24] is divisible by 4 so #[strong.m-red 2735]#[strong.m-green 24] #[+blank('is also|is not')] divisible by 4, and #[strong.m-green 18] is not divisible by 4 so #[strong.m-red 1947]#[strong.m-green 18] #[+blank('is also not|is')] divisible by 4.

//- ---------------------------------------------------------------------------

section
  p The divisibility rules for 8 get even more difficult, because 100 is not divisible by 8. Instead we have to go up to #[+blank("1000|800|108")] and look at the last #[+input(3)] digits of a number.
  p For example, #[strong.m-green 120] is divisible by 8 so #[strong.m-red 271]#[strong.m-green 120] is also divisible by 8.

//- ---------------------------------------------------------------------------

section
  p The easiest is the divisibility rule for 10: we just need to check if the #[+blank("last digit is a 0|first digit is a 1|last digit is even")].

  p Lets practice these divisibility rules for 2, 4, 5, 8 and 10 in this simple game:
  .box.problem-box
    .box-title: h3 Find the Divisor
    .box-body: p.todo Exercises under development…
    //- .box-body.bubble-pop
      .bubble-number 3653

//- ---------------------------------------------------------------------------

section#divisibility31
  h3 Divisibility by 3, 6and 9

  p The divisibility rule for 3 is rather more difficult. 3 doesn’t divide 10, and it also doesn’t divide 100, or 1000, or any larger power of 10. Simply looking at the last few digits of a number isn’t going to work.

  p Instead we need to use the #[strong digit sum] of a number, which is simply the sum of all its individual digits. For example, the digit sum of #[+var('n|3|0,20,1') 13*n+123] is #[+var digitSumString(123 + 13*n)] = #[+var digitSum(123 + 13*n)] and the digit sum of 3524 is #[+input(14)].

section#divisibility32
  +grid(40, function(n) { if (!(n % 3)) { var s = '' + n; return +s[0] + (+s[1] || 0); } })

  p Here we’ve highlighted all numbers which are multiples of three. You can see that their digit sums are always #[+blank("a multiple of 3|either 0 or 3|odd numbers")].

  p.subsection(data-needs="blank-0") So to determine if any number is divisible by 3, you just have to calculate its digit sum, and check if the result is also divisible by 3.

//- ---------------------------------------------------------------------------

section#divisibility9
  p Next, let’s look at multiples of 9:

  .number-grid
    for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
      .number-cell.yellow= x*9
        .number-badge= (x == 11 ? 18 : 9)

  p
    | It seems that all the numbers divisible by 9 have a digit sum which is #[+blank('also|not')] divisible by 9.
    span.subsection(data-needs="blank-0") For example, the digit sum of 4752 is #[+input(18)], so 4752 #[+blank("is|is not")] divisible by 9.

//- ---------------------------------------------------------------------------

section
  p Of course, these curious patterns for numbers divisible by 3 and 9 must have some reason – and like before it has to do with our base 10 numbers system. As we saw, writing the number #[strong.m-red 6]#[strong.m-blue 3]#[strong.m-green 8]#[strong.m-yellow 4] really means

  p.text-center #[strong.m-red 6 × 1000] + #[strong.m-blue 3 × 100] + #[strong.m-green 8 × 10] + #[strong.m-yellow 4].

  p We can split up each of these products into two parts:

  p.text-center #[strong.m-red #[span.digit-sum-else 6 × 999] + #[span.digit-sum-is 6]] + #[strong.m-blue #[span.digit-sum-else 3 × 99] + #[span.digit-sum-is 3]] + #[strong.m-green #[span.digit-sum-else 8 × 9] + #[span.digit-sum-is 8]] + #[strong.m-yellow.digit-sum-is 4].

  p Of course, #[strong.m-green 9], #[strong.m-blue 99], #[strong.m-red 999], and so on are always divisible by 3 (or by 9). All that remains is to check that what’s left over is also divisible by 3 (or 9):

  p.text-center #[strong.m-red 6] + #[strong.m-blue 3] + #[strong.m-green 8] + #[strong.m-yellow 4]

  p This just happens to be the digit sum! So if the #[x-target(to=".digit-sum-is", no-margins) digit sum] is a multiple of 3, and we know that #[x-target(to=".digit-sum-else", no-margins) everything else] is a multiple of 3, then the result must also be a multiple of 3.

//- ---------------------------------------------------------------------------

section#divisibility6
  p We’ve still skipped number 6 – but we’ve already done all the hard work. Remember that 6 = 2 × 3.
  +grid(40)
  p.btn-row.text-center(style="margin-bottom:1em")
    button.btn.btn-small.btn-bounce Show multiple of 2
    button.btn.btn-small.btn-bounce Show multiple of 3
  p To check if a number is divisible by 6 we just have to check that it is divisible by 2 #[+blank("and also|or")] divisible by 3. Note that this happens to work for 6, but certainly not for #[em any] number that is the product of two others. More on that later…

section
  p Unfortunately there is no simple divisibility rule for 7. However we now know the rules for all other numbers from 1 to 10, so let’s try a more advanced version of the divisibility game!
  .box.problem-box
    .box-title: h3 Find the Divisor
    .box-body
      p.todo Exercises under development…
      //- .bubble-number 3653

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section
  h2 Finding Factors

  p In many cases, it is not enough to find if a number is divisible by another – we need a list of #[em all] its divisors. For example, the divisors of 60 are 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30 and 60.

  p But we don’t want to have to try 60 different numbers and check which one is a divisor. Instead we can use a simple technique, which relies on the fact that divisors always appear in pairs.

//- ---------------------------------------------------------------------------

section
  p In the case of 60 we have 60 = 1 × 60 = 2 × 30 = 3 × 20 = 4 × 15 = 5 × 12 = 6 × 10. Or, in a different notation,

  +divisor-table([1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60], [5, 4, 3, 2, 1, 0])

  p To find all divisors of a number we simply start at both ends of this list, until we meet in the middle.

//- ---------------------------------------------------------------------------

section#factors2
  x-slideshow
    .stage
      +divisor-table([1, 2, 3, 6, 7, 14, 21, 42], [3, 2, 1, 0])
    .legend For example, the first divisor pair of 42 is simply 1 and 42, and we write them down with much space in between.
    .legend After 1 at the beginning, we check if 2 divides 42. It does, and the corresponding pair is 42 ÷ 2 = 21.
    .legend Next, we check if 3 divides 42. It does, and the corresponding pair if 42 ÷ 3 = 14.
    .legend Now we check if 4 divides 42. It does not, however, so we move on.
    .legend 5 also doesn’t divide 42 so we move on.
    .legend 6 does divide 42 again. Its pair is 42 ÷ 6 = 7. Notice how we’ve met in the middle after only a few attempts, without having to test all numbers from 7 to 42.

  p The only special case with this method is for square number: in that case, you will meet at just a single number in the middle, like 64 = 8 × 8.

//- ---------------------------------------------------------------------------

section
  .box.problem-box
    .box-title: h3 Factorisation
    .box-body: p.todo Exercises under development…

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section(data-gloss="prime")
  h2 Prime Numbers

  p When calculating these divisor pairs, it can happen that a number doesn’t have any divisors except for the first pair. One example is 13 – its only divisors are 1 and 13 itself. These special numbers are called #[strong Prime numbers]. They can’t be broken up into products of smaller numbers, which, in a way, makes them the “atoms of numbers”.

  p Note that 1 itself is #[em not] a prime number, so the first few prime numbers are 2, 3, 5, 7, 11, 13, …

  .box.problem-box
    .box-title: h3 Find the primes
    .box-body: p.todo Exercises under development…

//- ---------------------------------------------------------------------------

section(data-gloss="primefactor factorisation fta")

  p Any number which is not prime can be written as the product of prime numbers: we simply keep dividing it into more parts until all factors are prime. For example,

  table.table-tiny
    tr
      td(colspan=4)
      td: .number-ball.legs.b.a 84
    tr
      td(colspan=2)
      td: .number-ball.blue 2
      td(colspan=3) ×
      td: .number-ball.blue.legs.b 42
    tr
      td(colspan=4)
      td: .number-ball.green 2
      td(colspan=2) ×
      td: .number-ball.green.legs(style="margin: 0 -10px") 21
    tr.td-border-bottom
      td(colspan=6)
      td: .number-ball.yellow 3
      td ×
      td: .number-ball.yellow 7
    tr
      td: .number-ball 84
      td: | =
      td: .number-ball.blue 2
      td ×
      td: .number-ball.green 2
      td ×
      td: .number-ball.yellow 3
      td ×
      td: .number-ball.yellow 7

  p Now 2, 3 and 7 are prime numbers and can’t be divided further. The product 2 × 2 × 3 × 7 is called the #[strong prime factorisation] of 84, and 2, 3 and 7 are its #[strong prime factors]. Note that some primes, like 2 in this case, can appear multiple times in a prime factorisation.

  p Every integer has a prime factorisation and no two integers have the same prime factorisation. Furthermore, there is only a single way to write any number as a product of primes – unless we count different orderings of the primes. This is called the #[strong Fundamental Theorem of Arithmetic] (FTA).

  p Using the FTA can make many problems in mathematics much easier: we divide numbers into their prime factors, we solve the problem for the individual primes, which can often be much easier, and then we combine these results to solve the initial problem.

  .box.problem-box
    .box-title: h3 Find prime factorisations
    .box-body: p.todo Exercises under development…

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#eratosthenes
  h2 The Sieve of Eratosthenes

  p It turned out to be quite difficult to determine if a number is prime: you always had to find #[em all] its prime factors, which gets more and more challenging as the numbers get bigger. Instead, the Greek mathematician #[x-bio(xid='eratosthenes') Eratosthenes of Cyrene] came up with a simple algorithm to find all prime numbers up to 100: the #[strong Sieve of Eratosthenes].

  x-slideshow
    .stage
      +grid(100)
    .legend First we need to write down all numbers up to 100.
    .legend We know that 1 is not prime, so we delete it.
    .legend The smallest prime number is #[strong.m-red 2]. Any multiple of 2 can’t be prime, since it has 2 as a factor. Therefore we can cross out all multiples of 2.
    .legend The next number in our list is #[strong.m-blue 3] – again a prime number. All multiples of 3 can’t be prime, since they have 3 as a factor. Therefore we can cross these out as well.
    .legend The next number, 4, is already crossed out so we move on to #[strong.m-green 5]: it is a prime number and again we cross out all multiples of 5.
    .legend The next prime number must be #[+input(7)], since 6 is crossed out. Once more, we cross out all of its multiples.
    .legend The next prime number is #[+input(11)]. Notice, however, that all of its multiples are #[+blank('already crossed out|multiples of 3')]. The same is actually true for all other remaining numbers. Therefore all these remaining numbers must be prime.

  p Now we can count that, in total, there are #[+input(25)] prime numbers less than 100.

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section(data-gloss="proof")
  h2 How many Prime Numbers are there?

  .row
    .grow
      p Of course we can also use the Sieve of Eratosthenes to find larger prime numbers. There are 21 primes between 100 and 200, 16 primes between 200 and 300, 17 primes between 400 and 500 and only 11 between 10,000 and 10,100.
      p The primes seem to keep getting more and more spread out, but do they ever stop? Is there a #[em biggest] or a #[em last] prime number?
      p The ancient Greek mathematician #[x-bio(xid='euclid') Euclid of Alexandria] first proved that there are infinitely many prime numbers, using the following argument:
    div(style="width: 220px;")
      x-media(lightbox, width="220", height="300", src="/resources/divisibility-and-primes/images/euclid.jpg")

  ol.proof
    li Suppose there were only finitely many prime numbers.
      .text-center #[em.number-ball.blue P], #[em.number-ball.blue P], #[em.number-ball.blue P], #[em.number-ball.blue P], #[em.number-ball.blue P]
    li.subsection Let us multiply all of them together, to get a very large number which we call #[em N].
      .text-center #[em.number-ball N] = #[em.number-ball.blue P] × #[em.number-ball.blue P] × #[em.number-ball.blue P] × #[em.number-ball.blue P] × #[em.number-ball.blue P]
    li.subsection Now let’s think about #[em N] + 1. Any prime number that divides #[em N] can’t also  divide #[em N] + 1. And since all prime numbers we have found so far divide #[em N], none of these can also divide #[em N] + 1.
      .text-center #[em.number-ball.blue P], #[em.number-ball.blue P], #[em.number-ball.blue P], #[em.number-ball.blue P], #[.number-ball.blue P] #[span.divides] #[em.number-ball N]
      .text-center #[em.number-ball.blue.cross P], #[em.number-ball.blue.cross P], #[em.number-ball.blue.cross P], #[em.number-ball.blue.cross P], #[.number-ball.blue.cross P] #[span.divides] #[em.number-ball N] + 1
    li.subsection We know from the #[x-gloss(xid="fta") Fundamental Theorem of Arithmetic] that #[em N] + 1, must have a prime factor. Either #[em N] + 1 is itself prime, or there is some other new prime #[em P’] that divides #[em N] + 1.
      .text-center #[em.number-ball.green P’] #[span.divides] #[em.number-ball N] + 1
    li.subsection In both cases we’ve found a new prime not in our original list – but we assumed that #[em all] primes were in this list.
    li.subsection Clearly something went wrong! But since steps #[span.proof-step 2]–#[span.proof-step 4] were definitely valid, the only possibility is that our initial assumption in #[span.proof-step 1] was wrong. This means there must actually be infinitely many primes.

  //- Notice that any prime that divides N cannot divide N + 1. (If it would, it also had to divide the difference between N and N + 1 which is 1. But the only number that divides 1 is 1 itself.)

section
  p Euclid’s explanation is one of the first examples in history of a formal mathematical #[strong proof] – a logical argument that shows a statement must definitely be true. This example is often called #[em proof by contradiction]: we start with an assumption, deduce something impossible, and thus know that our assumption must be incorrect.

//- ---------------------------------------------------------------------------

section#primeTest
  h2 Large Primes

  p It is quite easy for a computer to check if a number is prime – simply by trying to divide it by all smaller numbers. But of course there are much cleverer and faster algorithms. Here you can try it yourself:

  .calculator
    h3 Prime Checker
    input(class="form-field", type="number" min="2")
    p.result.var ${result}

section
  .row
    .grow
      p Throughout history, people have tried to calculate larger and larger primes. In 1460, the largest known prime number was 131,071. In 1772, #[x-bio(xid='euler') Leonard Euler] showed that 2,147,483,647 is prime.
      p With the arrival of computers in the 20th century, calculating large primes became much faster and easier. Currently, the largest known prime number has 22,338,618 digits – you would need 5000 sheets of paper to print it out! It was discovered in September 2015 using a network of many thousands of computers around the world, run by volunteers, students and universities.

    div(style="width: 300px")
      img(src="/resources/divisibility-and-primes/images/network.jpg", width="300", height="200")
      p.caption The GIMPS Project (#[em Great Internet Mersenne Prime Search]) uses a network of computers around the world to find large prime numbers.

section#primeGenerator
  p You might think that calculating these primes is just a waste of time – but, as we will see below, it turns out to be incredibly useful for computers to be able to quickly find large prime numbers.

  p Rather than checking if a large number is definitely prime, there are also much faster algorithms that tell you that a number is #[em almost certainly] prime. Here you can generate your own, large prime numbers:

  .calculator
    h3 Prime Generator
    p Number of digits: #[+var('d|6|2,16,1') d]
    p(style="margin: 10px 0"): button.btn.btn-bounce.btn-white Generate
    p.result.var ${result}


//- ---------------------------------------------------------------------------

section#ulam
  //- Stanislaw M. Ulam was doodling during the presentation of a "long and very boring paper" at a scientific meeting in 1963.
  p The Polish mathematician #[x-bio(xid='ulam') Stanisław Ulam] came up with a cool way to show the distribution of large prime numbers, while doodling during a #[em "long and very boring"] meeting in 1963.

  .number-grid(style="max-width: 392px")
    for x in [37, 36, 35, 34, 33, 32, 31]
      .number-cell= x
    for x in [38, 17, 16, 15, 14, 13, 30]
      .number-cell= x
    for x in [39, 18,  5,  4,  3, 12, 29]
      .number-cell= x
    for x in [40, 19,  6,  1,  2, 11, 28]
      .number-cell= x
    for x in [41, 20,  7,  8,  9, 10, 27]
      .number-cell= x
    for x in [42, 21, 22, 23, 24, 25, 26]
      .number-cell= x
    for x in [43, 44, 45, 46, 47, 48, 49]
      .number-cell= x

  p We write down all integers in a rectangular grid, starting with 1 in the middle and then spiralling outwards. #[span.subsection Then we highlight all numbers which are prime.]

section
  p So far, the Ulam spiral doesn’t look particularly exciting. But if we zoom out, interesting patterns emerge. Here are the primes up to 160,000:
  .img-block: img(src="/resources/divisibility-and-primes/images/ulam.png", width="399", height="399")

  .row
    .grow
      p Rather than appearing randomly, as one might expect, it seems that certain diagonals are much more popular with primes than others. This creates a curious "plaid" pattern.
      p: em.lgrey It turns out that these diagonals all correspond to certain quadratic equations which seem to generate prime numbers more often than average. However it is unknown why that would be the case…

    div(style="width: 200px")
      x-media(lightbox, credit="© Scientific American", width="200", height="272", src="/resources/divisibility-and-primes/images/magazine.jpg")
      p.caption Cover of the March 1964 issue of Scientific American

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#race(data-gloss="lcm")
  h2 The Least Common Multiple

  p Two runners are training on a circular racing track. The #[strong.m-blue first runner] takes #[strong.m-blue 60] seconds for one lap. The #[strong.m-green second runner] only takes #[strong.m-green 40] seconds for one lap. If both leave at the same time from the start line, when will they meet again at the start?

  .img-block: include svg/race.svg

section
  p This question really isn’t about the geometry of the race track, or about velocity and speed – it is about multiples and divisibility.

  p The first runner crosses the start line after 60s, 120s, 180s, 240s, and so on. These are simply the #[+blank("multiples|factors")] of #[strong.m-blue 60]. The second runner crosses the start line after 40s, 80s, 120s, 160s, and so on. The first time both runners are back at the start line is after #[+input(120)] seconds.

  p.subsection(data-needs="blank-0 blank-1") What we’ve just found is the smallest number which is both a multiple of #[strong.m-green 40] and a multiple of #[strong.m-blue 60]. This is called the #[strong least common multiple] or #[strong lcm].

section

  p To find the lcm of any two numbers, it is important to realise that if #[strong.m-yellow a] divides #[strong.m-blue b], then #[strong.m-blue b] needs to have all the prime factors of #[strong.m-yellow a] (plus some more):

  table.table-tiny
    tr
      td.text-right: .number-ball.yellow 12
      td: .divides
      td.text-left: .number-ball.blue 60
    tr
      td
        .number-ball.l-yellow 2
        | &nbsp;×&nbsp;
        .number-ball.l-yellow 2
        | &nbsp;×&nbsp;
        .number-ball.l-yellow 3
      td
      td
        .number-ball.l-yellow 2
        | &nbsp;×&nbsp;
        .number-ball.l-yellow 2
        | &nbsp;×&nbsp;
        .number-ball.l-yellow 3
        | &nbsp;×&nbsp;
        .number-ball.l-blue 5

  p This is easy to verify: if a prime factor divides #[strong.m-yellow a], and #[strong.m-yellow a] divides #[strong.m-green b], then that prime factor must #[em also] divide #[strong.m-green b].

section
  p To find the lcm of #[strong.m-green 40] and #[strong.m-blue 60], we first need to find the #[x-gloss(xid="factorisation") prime factorisation] of both:

  table.table-tiny
    tr
      td: .number-ball.blue 40
      td: | =
      td: .number-ball.l-blue 2
      td: | ×
      td: .number-ball.l-blue 2
      td: | ×
      td: .number-ball.l-blue 2
      td(colspan=3): | ×
      td: .number-ball.l-blue 5
    tr
      td: .number-ball.green 60
      td: | =
      td: .number-ball.l-green 2
      td: | ×
      td: .number-ball.l-green 2
      td(colspan=3): | ×
      td: .number-ball.l-green 3
      td: | ×
      td: .number-ball.l-green 5

  p Suppose that #[strong.m-red X] is the lcm of #[strong.m-green 40] and #[strong.m-blue 60]. Then #[strong.m-green 40] divides #[strong.m-red X], so #[span.number-ball.small.l-blue 2], #[span.number-ball.small.l-blue 2], #[span.number-ball.small.l-blue 2] and #[span.number-ball.small.l-blue 5] must be prime factors of #[strong.m-red X]. Also, #[strong.m-blue 60] divides #[strong.m-red X], so #[span.number-ball.small.l-green 2], #[span.number-ball.small.l-green 2], #[span.number-ball.small.l-green 3] and #[span.number-ball.small.l-green 5] must be prime factors of #[strong.m-red X].

section
  p To find #[strong.m-red X], we simply combine all the prime factors of #[strong.m-green 40] and #[strong.m-blue 60], but any duplicates we only need once:

  p.text-center #[strong.m-red X] &nbsp;=&nbsp; #[span.number-ball.l-blue-green 2] × #[span.number-ball.l-blue-green 2] × #[span.number-ball.l-blue 2] × #[span.number-ball.l-green 3] × #[span.number-ball.l-blue-green 5]

  p This gives us that #[strong.m-red X] = 120, just like we saw above. Notice that if the same prime factor appears multiple times, like 2 above, we need to keep the maximum occurrences in one of the two numbers (3 times in #[strong.m-green 40] is more than 2 times in #[strong.m-blue 60]).

section
  p Now we have a simple method for finding the lcm of two numbers:

  ol.proof
    li Find the prime factorisation of each number.
    li Combine all prime factors, but only count duplicates once.

  p We can use the same method to find the lcm of three or more numbers at once, like #[strong.m-blue 12], #[strong.m-green 30] and #[strong.m-yellow 45]:

  table.table-tiny
    tr
      td: .number-ball.blue 12
      td: | =
      td: .number-ball.l-blue 2
      td: | ×
      td: .number-ball.l-blue 2
      td: | ×
      td: .number-ball.l-blue 3
    tr
      td: .number-ball.green 30
      td: | =
      td: .number-ball.l-green 2
      td(colspan=3): | ×
      td: .number-ball.l-green 3
      td(colspan=3): | ×
      td: .number-ball.l-green 5
    tr
      td: .number-ball.yellow 45
      td: | =
      td(colspan=4)
      td: .number-ball.l-yellow 3
      td: | ×
      td: .number-ball.l-yellow 3
      td: | ×
      td: .number-ball.l-yellow 5

  p Therefore the lcm of #[strong.m-blue 12], #[strong.m-green 30] and #[strong.m-yellow 45] is 2 × #[+input(2)] × 3 × 3 × #[+input(5)] = 180.

section
  p A special case are prime numbers: the lcm of two different primes is simply their #[+blank("product|sum|difference")], because they don’t have any common prime factors which would get “canceled”.

//- section
  p Try finding the lowest common multiple of these examples:

  .box.problem-box
    .box-title: h3 Find the LCM
    .box-body: p.todo Exercises under development…

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#gcd(data-gloss="gcd")
  h2 The Greatest Common Factor

  p An architect is planning the floor for a large courtyard that measures 18m by 30m. She wants it to be covered in quadratic tiles, without any gaps or overlaps along the sides. What is the largest size of squares she can use?

  .img-block
    include svg/floorplan.svg
    p.text-center The tiles have a size of #[+var('x|3|1,18,1') x]m.#[br]#[+var result]

section
  p Just like before, this question is not about geometry - it is about divisibility. The length of the sides of the tiles has to divide both 18 and 30, and the largest possible number with that property is #[+input(6)]. This is called the #[strong Greatest Common Divisor] or #[strong gcd] of 18 and 30.

section
  p Once again, we can use the #[x-gloss(xid="factorisation") prime factorisation] to calculate the gcd of any two numbers. Remember that any divisor of a number must have some of the prime factors of that number.

  table.table-tiny
    tr
      td: .number-ball.blue 18
      td: | =
      td: .number-ball.l-blue 2
      td: | ×
      td: .number-ball.l-blue 3
      td: | ×
      td: .number-ball.l-blue 3
    tr
      td: .number-ball.green 30
      td: | =
      td: .number-ball.l-green 2
      td: | ×
      td: .number-ball.l-green 3
      td(colspan=3): | ×
      td: .number-ball.l-green 5

  p Suppose that #[strong.m-red X] is the gcd of #[strong.m-green 18] and #[strong.m-blue 30]. Then #[strong.m-red X] divides #[strong.m-green 18] so the prime factors of #[strong.m-red X] must be among #[span.number-ball.small.l-blue 2], #[span.number-ball.small.l-blue 2] and #[span.number-ball.small.l-blue 3]. Also, #[strong.m-red X] divides #[strong.m-blue 30] so the prime factors of #[strong.m-red X] must be among #[span.number-ball.small.l-green 2], #[span.number-ball.small.l-green 3] and #[span.number-ball.small.l-green 5].

section
  p To find #[strong.m-red X], we simply need to multiply all numbers which are  prime factors of #[+blank("both|one of")] #[strong.m-green 18] and #[strong.m-blue 30]:

  p.text-center #[strong.m-red X] &nbsp;=&nbsp; #[span.number-ball.l-blue-green 2] × #[span.number-ball.l-blue-green 3] &nbsp;=&nbsp; 6.

section
  p Now we have a simple method for finding the gcd of two numbers:

  ol.proof
    li Find the prime factorisation of each number.
    li Multiple the prime factors which are in both numbers.

  p Once again prime numbers are special: the gcd of two different primes is always #[+input(1)], because they don’t share any prime factors.

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#cicadas
  h2 LCM and GCD Applications

  .row
    .grow
      p North America is home to various broods of cicadas. These have the curious property that they only emerge every few years during the summer to breed – the remaining time they spend underground.
      p For example, the cicadas in Florida and Mississippi appear every 13 years. The cicadas in Illinois and Iowa only appear every 17 years. But there are no cicadas with 12, 14, 15 or 16 year cycles.
    div(style="width: 360px"): x-media(credit="© Depositphotos", width="360", height="240", src="/resources/divisibility-and-primes/images/cicadas.jpg")

  p Both 13 and 17 are prime numbers – and that has a very good reason. Imagine that there are predators in the forest which kill cicadas. These predators also appear in regular intervals, say every 6 years.

  p Now imagine that a brood of cicadas appears every #[+var('n|13|4,20,1') n] years (#[+var isPrime(n) ? 'prime' : 'not prime']). The two animals would meet every #[+var lcm(n, 6)] years, which is the #[+blank('lcm|gcd|product')] of 6 and #[+var n].

  .img-block
    include svg/cicadas.svg
    p.caption Time until cicadas and predators meet, for various different cicada cycle lengths.

section
  p  This number seems to be much larger if the cicada cycle is a prime number like 13 and 17. That‘s is because prime numbers don‘t share any factors with 6, so when calculating the lcm we don‘t cancel any duplicate factors.

  p Of course, cicadas have no idea what prime numbers are – but over millions of years, evolution has worked out that prime cycles are the safest. The predator animal seems to have gone extinct over time, but the prime number cycles remain.

section
  p There are many other applications of lcm and gcd in nature, technology or everyday life…
  .box.problem-box
    .box-title: h3 LCM and GCD Word Problems
    .box-body: p.todo Exercises under development…

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section(data-gloss="cryptography")
  h2 Primes in Cryptography

  .row
    .grow
      p One of the most important modern applications of prime numbers is in a field of mathematics called #[strong Cryptography]. For thousands of years, people have tried to conceal messages so that only the intended recipient could read them – this is called encryption. It is used by everyone from generals exchanging secret orders during wars to personal emails or online banking details.

      p People always tried to come up with better, more secure encryption methods, but after some time, they were all broken using yet more advanced algorithms. In the Second World War, the German army used the Enigma: a complex machine consisting of a keyboard, rotating wheels and plugs. It encrypted messages using one of 158 million million million possibilities (that’s a 158 followed by 18 zeros!). The code was widely belied to be unbreakable, but the British Secret Service, led by mathematician Alan Turing, built some of the first computers that managed to decode it.

    div(style="width: 240px")
      x-media(lightbox, credit="Magnus Manske, via Wikipedia", width="240", height="344", src="/resources/divisibility-and-primes/images/enigma.jpg")
      p.caption German four-rotor Enigma machine

  p Today’s computers are much more advanced, capable of trying millions of possibilities every second. To develop better encryption algorithms you have to find a mathematical operations that is difficult for a powerful computers. Computers are incredibly fast at addition, subtraction, multiplication and division. However, as it turns out, computers are very slow at factorising large integers into primes…

//- section
  p Imagine that Alice wants to send a secret message to Bob. Bob starts by randomly picking two very large prime numbers, let’s call them p and q. # pick p, pick q

  p Calculating the product is very easy using a computer: N = p * q = ${p*q}. However, if you only know this product it is incredibly difficult to reconstruct the two original prime factors. You would essentially have to try every possible factor, and even using every computer ever built this could take thousands of years.

  p The product of p and q is called Bob’s _public key_: he publishes it on the internet, visible for anyone including Alice. Now Alice writes her secret message. She then uses Bob’s public key N to encrypt the message.

  p You only need to know N to encrypt the message, but to revert it back to readable text you also need to know the original factors p and q. Since only Bob knows the original factors, and no one can calculate them quickly, Bob is the only one who can read Alice’s method.

section
  p.todo RSA example with Alice and Bob coming soon…

  p This encryption algorithm is called #[strong RSA Cryptography], after its three inventors, Ron Rivest, Adi Shamir and Leonard Adleman who published it in 1977. It turns out that a very similar method was known to the British Secret Service since 1973, but remained classified until much later.

  p Today, prime numbers are used by computers all over the world to exchange data. Whenever you send an email or visit a secure website, your phone or laptop quietly generates large prime numbers and exchanges public keys with other computers.

//- ---------------------------------------------------------------------------
//- ---------------------------------------------------------------------------

section#goldbach1

  h2 Mysteries and Unsolved Problems

  p In 1742, the German mathematician #[x-bio(xid='goldbach') Christian Goldbach] made a curious discovery: he noticed that all even integers (except 2) can be written as the sum of two prime numbers. For example, 8 = 5 + 3 and 24 = 13 + 11. This is quite surprising, because primes are defined using multiplication and factors – and shouldn’t have much to do with addition.

  .calculator
    h3 Goldbach Calculator
    p Pick any even number, to calculate how it#[br]can be written as the sum of two primes.

    input(class="form-field", type="number", min=4, step=2)
    p.result.var ${result}

  p Goldbach wrote about his observation in a letter to the famous mathematician #[x-bio(xid='euler') Leonhard Euler], but neither of them was able to prove it. It became known as the #[strong Goldbach Conjecture].

  p Computers have checked that the Goldbach Conjecture works for every even number up to 4 × 10#[sup 18] (that’s a 4 with 18 zeros), but mathematicians have still not found a proof that it works for #[em all] even integers. And that is a big difference, because there are infinitely many integers, so we couldn’t possible check all of them.

  p Its apparent simplicity made the Goldbach conjecture one of the most famous unsolved problems in mathematics.

//- ---------------------------------------------------------------------------

section(data-gloss="twins")

  p.text-center •

  p We have already seen that prime numbers get more spread out as they get bigger. But they always seem to appear completely random, and occasionally we find two primes right next to each other, just one number apart: these are called #[strong Twin Primes].

  p.text-center
    span.twin
      span.number-ball 3
      span.number-ball 5
    | ,
    span.twin
      span.number-ball.blue 11
      span.number-ball.blue 13
    | ,
    span.twin
      span.number-ball.green 41
      span.number-ball.green 43
    | ,
    span.twin
      span.number-ball.yellow 101
      span.number-ball.yellow 103
    | ,
    span.twin
      span.number-ball 2027
      span.number-ball 2029
    | ,
    span.twin
      span.number-ball.blue 108,377
      span.number-ball.blue 108,379
    | ,
    span.twin
      span.number-ball.green 1,523,651
      span.number-ball.green 1,523,653

  p The largest known pair of twin primes has an incredible 58,711 digits! But are there infinitely many twin primes, just like there are infinitely many primes? Nobody knows – the #[em Twin Prime conjecture] is another one of the many unsolved problems surrounding the primes.

//- ---------------------------------------------------------------------------

section#riemann

  p.text-center •

  p Mathematicians have spent many centuries exploring the pattern and distribution of prime numbers. They seem to appear completely randomly – sometimes there are huge gaps in between consecutive primes, and sometimes we find #[x-gloss(xid="twins") twin primes] right next to each other.

  p When only 15 years old, the German mathematician #[x-bio(xid='gauss') Carl Friedrich Gauss] had a groundbreaking new idea: he counted the number of primes up to a certain point, and showed the results in a chart:

  .img-block(style="max-width:680px;position:relative;")
    svg(width=680, height=300, viewBox="0 0 680 300")
      line.axis(x1=0, y1=280, x2=680, y2=280)
      g.chart
        path.pi(fill="none", stroke="#1f7aff")
        path.log(fill="none", stroke="#b30469")
        g.small-primes
      g.numbers
    .zoom-icon: svg(viewBox="0 0 32 32", class="icon", width=32, height=32): use(xlink:href="/icons.svg#search")

  p Along the x-axis you can see all integers. Whenever there is a prime, the #[em.m-blue Prime Counting Function] increases by one. As we #[x-target(to="#riemann .zoom-icon") zoom out], the blue line becomes very smooth.

  p.subsection(data-needs="zoom") Gauss noticed that the shape of this function looks very similar to the function #[mfrac.inline.m-red #[mrow #[mi x]]#[mrow log(#[mi x])]]. He predicted that the two functions are always “approximately similar”, and this was proven in 1896.

section
  p However, as you can see above, there is still a significant error between the actual number of primes, and Gauss’s approximation. In 1859, the mathematician #[x-bio(xid='riemann') Bernhard Riemann] discovered an approximation that looked much better, but he wasn’t able to prove that that would #[em always] work. His idea became known as the #[strong Riemann Hypothesis].

  p Hundreds of mathematicians have tried to prove Riemann’s hypothesis, but all without success. It is often considered one of the most difficult and most important unsolved problems in mathematics. In 2000, the Clay Mathematics Institute named it one of six #[strong Millennium Prize Problems] and promised $1,000,000 to any mathematician who solves it.
